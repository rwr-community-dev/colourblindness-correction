#include "tools.cg"

/*
// integrated outline
void soldier_skin_vp(
             uniform float4x4 matrices[17],
             uniform float4x4 viewProj,
             uniform float pointSize,
//		     uniform float4 fogColor,
// 		     uniform float4 fogParams,

            
              float4 position : POSITION,
              float4 color    : COLOR,
             float  u	     : TEXCOORD0,
                
             out float4 outPosition : POSITION,
             out float4 outColor	: COLOR,
// for some reason, nvidia seems to have all texcoord* as texture coordinates
// for the point sprite in fragment shader, it's no use passing anything
// here
//    		 out float4 outFogColor : TEXCOORD1,
             out float  outSize     : PSIZE)
{

    float4x4 result = matrices[u];
    result = mul(viewProj, result);
    outPosition = mul(result, position);

    // color.a carries info about outline mesh
    // 0 means outline, 1 means colors
    float outlineFactor = 1.0 - color.a;

    outColor.rgb = color.rgb * color.a;
    outColor.a = 1.0;

    outSize = pointSize * (1.0 + outlineFactor);	

    //outFogColor = fog(fogColor, oPosition.z, fogParams);

    outPosition.z = outPosition.z + 0.005 * outlineFactor;
}
*/


void soldier_skin_vp(
    uniform float4x4 matrices[17],
    uniform float4x4 viewProj,
    //uniform float4 fogColor,
    //uniform float4 fogParams,

    float4 position : POSITION,
    float4 color    : COLOR,
    float  u	    : TEXCOORD0,
                
    out float4 outPosition : POSITION,
    out float4 outColor	: COLOR)
    // for some reason, nvidia seems to have all texcoord* as texture coordinates
    // for the point sprite in fragment shader, it's no use passing anything
    // here
    //out float4 outFogColor : TEXCOORD1,
{

    float4x4 result = matrices[u];
    result = mul(viewProj, result);
    outPosition = mul(result, position);

    outColor.rgb = color.rgb;
    outColor.a = 1.0;

    //outFogColor = fog(fogColor, oPosition.z, fogParams);
}

void soldier_skin_fp(
    float4 color               : COLOR,
    float4 uv                  : TEXCOORD0,

    uniform float4 fogColor,
    uniform float4 fogParams,
    uniform float4 cameraPositionInObjectSpace,
    uniform float4 diffuseLightColor,

    out float4 result          : COLOR)
{
    // apply some internal shading, just a bit, too much causes ants
    float factor = 0.85;
    color *= step(0.5, 1.0 - uv.y) * (1.0 - factor) + factor;

    // apply some diffuse light
    color = (color * 0.75 + diffuseLightColor * color * 0.95);	

    float4 f = fog(fogColor, length(cameraPositionInObjectSpace), fogParams);
    f.a *= 0.9;
    float4 res = blend_fog(f, color);

    // LICENSE: <start>
    // LICENSE: CC0 (ty "kwineffects/colorblindnesscorrection/shaders/README")
    // color correction
    // conversion to LMS
    float L = (17.8824 * res.r) + (43.5161 * res.g) + (4.11935 * res.b);
    float M = (3.45565 * res.r) + (27.1554 * res.g) + (3.86714 * res.b);
    float S = (0.0299566 * res.r) + (0.184309 * res.g) + (1.46709 * res.b);

    // daltonization:
    // (comment in/out the relevant section below as appropriate)
    // *deuteranopia*
    //float l = 1.0 * L + 0.0 * M + 0.0 * S;
    //float m = 0.494207 * L + 0.0 * M + 1.24827 * S;
    //float s = 0.0 * L + 0.0 * M + 1.0 * S;
    // ^deuteranopia^

    // *protanopia*
    //float l = 0.0 * L + 2.02344 * M + -2.52581 * S;
    //float m = 0.0 * L + 1.0 * M + 0.0 * S;
    //float s = 0.0 * L + 0.0 * M + 1.0 * S;
    // ^protanopia^

    // *tritanopia*
    float l = 1.0 * L + 0.0 * M + 0.0 * S;
    float m = 0.0 * L + 1.0 * M + 0.0 * S;
    float s = -0.395913 * L + 0.801109 * M + 0.0 * S;
    // ^tritanopia^


    // error calc
    float4 error;
    error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);
    error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);
    error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);
    error.a = res.a;

    // diff and correct
    float4 diff = res - error;
    float4 correction;
    correction.r = 0.0;
    correction.g = (diff.r * 0.7) + (diff.g * 1.0);
    correction.b = (diff.r * 0.7) + (diff.b * 1.0);
    correction = res + correction;

    // ignore correction
    //result = res;
    // pass correction
    result = correction;

   // LICENSE: <end>
}


void soldier_skin_ghost_vp(
    uniform float4x4 matrices[17],
    uniform float4 teamColor,
            
    uniform float4x4 viewProj,
    uniform float4 ambient,

    float4 position : POSITION,
    float4 color : COLOR,
    float u : TEXCOORD0,

    out float4 oPosition : POSITION,
    out float4 oColor : COLOR)
{
    float4x4 result = matrices[u];
    result = mul(viewProj, result);
    oPosition = mul(result, position);

    float weight = 0.5;
    oColor.rgb = weight * ambient.rgb + (1.0 - weight) * teamColor.rgb * 1.2;
    oColor.a = 1.0;
}

void soldier_skin_ghost_fp(
    float4 color              : COLOR,
    out float4 result         : COLOR)
{
    result = color;
}


void soldier_skin_shadow_vp(
    uniform float4x4 matrices[17],
    uniform float4x4 viewProj,
    uniform float4 texelOffsets,

    float4 position : POSITION,
    float  u	     : TEXCOORD0,
                
    out float4 oPosition : POSITION,
    out float2 outDepth        : TEXCOORD0)
{

    int index = u;

    float4x4 result = matrices[u];
    result = mul(viewProj, result);
    oPosition = mul(result, position);

    // fix pixel / texel alignment
    oPosition.xy += texelOffsets.zw * oPosition.w;
    outDepth.x = oPosition.z;
    outDepth.y = oPosition.w;
}


void soldier_skin_normal_and_depth_vp(
    uniform float4x4 matrices[17],
    uniform float4x4 viewProj,

    float4 position : POSITION,
    float  u	     : TEXCOORD0,

    uniform float nearDepth,
    uniform float farDepth,
                
    out float4 oPosition : POSITION,
    out float4 oNormalDepth : COLOR) 
{

    int index = u;

    float4x4 result = matrices[u];
    result = mul(viewProj, result);
    oPosition = mul(result, position);

    oNormalDepth.r = 0.5;
    oNormalDepth.g = 0.5;
    oNormalDepth.b = 0.0;

    //oPosition.z -= 0.0;
    
    oNormalDepth.a = saturate((oPosition.z - nearDepth) / (farDepth - nearDepth));
}

void soldier_skin_normal_and_depth_fp(
    float4 color : COLOR,
    out float4 oColor : COLOR)
{
    oColor = color;
}


void soldier_skin_outline_vp(
    uniform float4x4 matrices[17],
    uniform float4x4 viewProj,

    float4 position : POSITION,
    float4 color    : COLOR,
    float  u	     : TEXCOORD0,
                
    out float4 oPosition : POSITION,
    out float4 oColour	 : COLOR) 
{

    float4x4 result = matrices[u];
    result = mul(viewProj, result);
    oPosition = mul(result, position);
    //oPosition.z = oPosition.z + 0.01;
    oPosition.z = oPosition.z + 0.005;

    oColour.r = 0.0;
    oColour.g = 0.0;
    oColour.b = 0.0;
    oColour.a = 1.0;
}

void soldier_skin_outline_fp(
    float4 color : COLOR,

    uniform float4 fogColor,
    uniform float4 fogParams,
    uniform float4 cameraPositionInObjectSpace,

    out float4 oColor : COLOR)
{
    float4 f = fog(fogColor, length(cameraPositionInObjectSpace), fogParams);
    f.a *= 0.8;
    oColor = blend_fog(f, color);
    
    //oColor = color;
}
